package com.mapconverter.generator;

import com.mapconverter.processor.ExternalMappingConfig;
import com.mapconverter.processor.FieldInfo;
import com.palantir.javapoet.ClassName;
import com.palantir.javapoet.JavaFile;
import com.palantir.javapoet.MethodSpec;
import com.palantir.javapoet.TypeSpec;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import java.io.IOException;
import java.util.List;

/**
 * Generates mapper classes using JavaPoet.
 * Refactored to use specialized generators for different concerns.
 */
public class MapperCodeGenerator extends AbstractCodeGenerator {
    
    private final Filer filer;
    
    // Specialized generators
    private final TemporalCodeGenerator temporalGenerator;
    private final NestedObjectCodeGenerator nestedObjectGenerator;
    private final CollectionCodeGenerator collectionGenerator;
    private final RecordCodeGenerator recordGenerator;
    private final ClassCodeGenerator classGenerator;
    private final ExternalMapperGenerator externalMapperGenerator;
    
    public MapperCodeGenerator(Filer filer, Elements elementUtils, Types typeUtils) {
        super(elementUtils, typeUtils);
        this.filer = filer;
        
        // Initialize specialized generators
        this.temporalGenerator = new TemporalCodeGenerator(elementUtils, typeUtils);
        this.nestedObjectGenerator = new NestedObjectCodeGenerator(elementUtils, typeUtils);
        this.collectionGenerator = new CollectionCodeGenerator(elementUtils, typeUtils);
        this.classGenerator = new ClassCodeGenerator(elementUtils, typeUtils, temporalGenerator, nestedObjectGenerator, collectionGenerator);
        this.recordGenerator = new RecordCodeGenerator(elementUtils, typeUtils, temporalGenerator, nestedObjectGenerator, collectionGenerator);
        this.externalMapperGenerator = new ExternalMapperGenerator(elementUtils, typeUtils);
        
        // Set up circular dependencies
        this.collectionGenerator.setTemporalGenerator(temporalGenerator);
    }
    
    public void generateMapper(TypeElement originalClass, String mapperClassName, List<FieldInfo> fields, boolean isRecord) throws IOException {
        String packageName = elementUtils.getPackageOf(originalClass).getQualifiedName().toString();
        ClassName originalClassName = ClassName.get(originalClass);
        
        String typeKind = isRecord ? "record" : "class";
        TypeSpec.Builder mapperBuilder = TypeSpec.classBuilder(mapperClassName)
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addJavadoc("Generated mapper for {@link $T}\n", originalClassName)
            .addJavadoc("Provides bidirectional conversion between $T " + typeKind + " and Map&lt;String, Object&gt;\n", originalClassName);
        
        // Add static final String constants for map keys
        MapperUtility.addMapKeyConstants(mapperBuilder, fields);
        
        // Analyze if circular reference checking is needed
        boolean needsCircularRefCheck = needsCircularReferenceCheck(fields);
        
        // Add thread-local visited set pool for efficient circular reference handling (only if needed)
        if (needsCircularRefCheck) {
            MapperUtility.addVisitedSetPool(mapperBuilder);
        }
        
        // Generate methods using appropriate specialized generator
        addMapperMethods(mapperBuilder, originalClassName, fields, isRecord, needsCircularRefCheck);
        
        TypeSpec mapperType = mapperBuilder.build();
        
        JavaFile javaFile = JavaFile.builder(packageName, mapperType)
            .addFileComment("Generated by Fast Map Converter")
            .build();
        javaFile.writeTo(filer);
    }

    /**
     * Generates an external mapper class for a third-party object.
     */
    public void generateExternalMapper(ExternalMappingConfig config) throws IOException {
        externalMapperGenerator.generateExternalMapper(config, filer);
    }

    /**
     * Backward compatibility method for existing code.
     */
    public void generateMapper(TypeElement originalClass, String mapperClassName, List<FieldInfo> fields) throws IOException {
        generateMapper(originalClass, mapperClassName, fields, false);
    }

    private void addMapperMethods(TypeSpec.Builder mapperBuilder, ClassName originalClassName, 
                                 List<FieldInfo> fields, boolean isRecord, boolean needsCircularRefCheck) {
        MethodSpec toMapMethod;
        MethodSpec toMapWithTrackingMethod = null;
        MethodSpec fromMapMethod;
        MethodSpec toMapDirectMethod = null;

        if (isRecord) {
            toMapMethod = recordGenerator.generateToMapMethodForRecord(originalClassName, fields, needsCircularRefCheck);
            if (needsCircularRefCheck) {
                toMapWithTrackingMethod = recordGenerator.generateToMapWithTrackingMethodForRecord(originalClassName, fields);
            } else {
                toMapDirectMethod = recordGenerator.generateToMapDirectMethodForRecord(originalClassName, fields);
            }
            fromMapMethod = recordGenerator.generateFromMapMethodForRecord(originalClassName, fields);
        } else {
            toMapMethod = classGenerator.generateToMapMethod(originalClassName, fields, needsCircularRefCheck);
            if (needsCircularRefCheck) {
                toMapWithTrackingMethod = classGenerator.generateToMapWithTrackingMethod(originalClassName, fields);
            } else {
                toMapDirectMethod = classGenerator.generateToMapDirectMethod(originalClassName, fields);
            }
            fromMapMethod = classGenerator.generateFromMapMethod(originalClassName, fields);
        }

        // Add methods to mapper
        mapperBuilder.addMethod(toMapMethod);
        if (toMapWithTrackingMethod != null) {
            mapperBuilder.addMethod(toMapWithTrackingMethod);
        }
        if (toMapDirectMethod != null) {
            mapperBuilder.addMethod(toMapDirectMethod);
        }
        mapperBuilder.addMethod(fromMapMethod);
    }
}