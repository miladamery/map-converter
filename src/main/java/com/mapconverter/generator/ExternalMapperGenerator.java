package com.mapconverter.generator;

import com.mapconverter.processor.ExternalMappingConfig;
import com.palantir.javapoet.ClassName;
import com.palantir.javapoet.CodeBlock;
import com.palantir.javapoet.JavaFile;
import com.palantir.javapoet.MethodSpec;
import com.palantir.javapoet.ParameterizedTypeName;
import com.palantir.javapoet.TypeName;
import com.palantir.javapoet.TypeSpec;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Specialized generator for external mapper classes.
 */
public class ExternalMapperGenerator extends AbstractCodeGenerator {
    
    public ExternalMapperGenerator(Elements elementUtils, Types typeUtils) {
        super(elementUtils, typeUtils);
    }

    /**
     * Generates an external mapper class for a third-party object.
     */
    public void generateExternalMapper(ExternalMappingConfig config, Filer filer) throws IOException {
        String packageName = config.getPackageName();
        TypeName targetTypeName = TypeName.get(config.getTargetClass());
        
        TypeSpec.Builder mapperBuilder = TypeSpec.classBuilder(config.getMapperName())
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addJavadoc("Generated external mapper for {@link $T}\n", targetTypeName)
            .addJavadoc("Configuration class: {@link $T}\n", TypeName.get(config.getConfigClass().asType()))
            .addJavadoc("Provides bidirectional conversion between $T and Map&lt;String, Object&gt;\n", targetTypeName);
        
        // Add static final String constants for external mapper keys
        addExternalMapKeyConstants(mapperBuilder, config.getFields());
        
        // Add toMap method
        MethodSpec toMapMethod = generateExternalToMapMethod(config);
        mapperBuilder.addMethod(toMapMethod);
        
        // Add fromMap method
        MethodSpec fromMapMethod = generateExternalFromMapMethod(config);
        mapperBuilder.addMethod(fromMapMethod);
        
        TypeSpec mapperType = mapperBuilder.build();
        
        JavaFile javaFile = JavaFile.builder(packageName, mapperType)
            .addFileComment("Generated by Fast Map Converter - External Mapper")
            .build();
        
        javaFile.writeTo(filer);
    }

    private MethodSpec generateExternalToMapMethod(ExternalMappingConfig config) {
        TypeName targetTypeName = TypeName.get(config.getTargetClass());
        TypeName mapType = createMapType();
        
        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("toMap")
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .returns(mapType)
            .addParameter(targetTypeName, "obj")
            .addJavadoc("Converts a $T instance to a Map&lt;String, Object&gt;\n", targetTypeName)
            .addJavadoc("@param obj the external object to convert\n")
            .addJavadoc("@return the resulting map\n");
        
        methodBuilder.addStatement("if (obj == null) return null");
        
        // Create map with pre-sized capacity
        int nonIgnoredFieldCount = (int) config.getFields().stream().filter(field -> !field.isIgnored()).count();
        int initialCapacity = calculateOptimalCapacity(nonIgnoredFieldCount);
        methodBuilder.addStatement("$T map = new $T<>($L)", mapType, HashMap.class, initialCapacity);
        
        // Generate field conversion code
        for (ExternalMappingConfig.ExternalFieldConfig fieldConfig : config.getFields()) {
            if (fieldConfig.isIgnored()) {
                continue;
            }
            generateExternalFieldToMapCode(methodBuilder, fieldConfig);
        }
        
        methodBuilder.addStatement("return map");
        return methodBuilder.build();
    }

    private MethodSpec generateExternalFromMapMethod(ExternalMappingConfig config) {
        TypeName targetTypeName = TypeName.get(config.getTargetClass());
        TypeName mapType = createMapType();
        
        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("fromMap")
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .returns(targetTypeName)
            .addParameter(mapType, "map")
            .addJavadoc("Converts a Map&lt;String, Object&gt; to a $T instance\n", targetTypeName)
            .addJavadoc("@param map the map to convert\n")
            .addJavadoc("@return the resulting external object\n");
        
        methodBuilder.addStatement("if (map == null) return null");
        methodBuilder.addStatement("$T obj = new $T()", targetTypeName, targetTypeName);
        
        // Generate field assignment code
        for (ExternalMappingConfig.ExternalFieldConfig fieldConfig : config.getFields()) {
            if (fieldConfig.isIgnored()) {
                continue;
            }
            generateExternalFieldFromMapCode(methodBuilder, fieldConfig);
        }
        
        methodBuilder.addStatement("return obj");
        return methodBuilder.build();
    }

    private void generateExternalFieldToMapCode(MethodSpec.Builder methodBuilder, 
                                              ExternalMappingConfig.ExternalFieldConfig fieldConfig) {
        String getterName = generateGetterName(fieldConfig.getTargetFieldName(), fieldConfig.getFieldType());
        String mapKey = fieldConfig.getMapKey();
        
        if (fieldConfig.hasCustomConverter()) {
            generateCustomConverterToMapCode(methodBuilder, fieldConfig, getterName, mapKey);
        } else if (fieldConfig.isCollection()) {
            generateExternalCollectionToMapCode(methodBuilder, fieldConfig, getterName, mapKey);
        } else if (fieldConfig.isExternalObject()) {
            generateExternalNestedObjectToMapCode(methodBuilder, fieldConfig, getterName, mapKey);
        } else if (isPrimitive(fieldConfig.getFieldType())) {
            methodBuilder.addStatement("map.put($S, obj.$L())", mapKey, getterName);
        } else {
            methodBuilder.addCode(CodeBlock.builder()
                .beginControlFlow("if (obj.$L() != null)", getterName)
                .addStatement("map.put($S, obj.$L())", mapKey, getterName)
                .endControlFlow()
                .build());
        }
    }

    private void generateExternalFieldFromMapCode(MethodSpec.Builder methodBuilder, 
                                                ExternalMappingConfig.ExternalFieldConfig fieldConfig) {
        String setterName = generateSetterName(fieldConfig.getTargetFieldName());
        String mapKey = fieldConfig.getMapKey();
        TypeName fieldTypeName = TypeName.get(fieldConfig.getFieldType());
        
        methodBuilder.addCode(CodeBlock.builder()
            .beginControlFlow("if (map.containsKey($S))", mapKey)
            .addStatement("Object value = map.get($S)", mapKey)
            .build());
        
        if (fieldConfig.hasCustomConverter()) {
            generateCustomConverterFromMapCode(methodBuilder, fieldConfig, setterName);
        } else if (fieldConfig.isCollection()) {
            generateExternalCollectionFromMapCode(methodBuilder, fieldConfig, setterName);
        } else if (fieldConfig.isExternalObject()) {
            generateExternalNestedObjectFromMapCode(methodBuilder, fieldConfig, setterName);
        } else {
            methodBuilder.addCode(CodeBlock.builder()
                .beginControlFlow("if (value != null)")
                .addStatement("obj.$L(($T) value)", setterName, fieldTypeName)
                .endControlFlow()
                .build());
        }
        
        methodBuilder.endControlFlow();
    }

    private void generateCustomConverterToMapCode(MethodSpec.Builder methodBuilder, 
                                                ExternalMappingConfig.ExternalFieldConfig fieldConfig, 
                                                String getterName, String mapKey) {
        TypeName converterType = TypeName.get(fieldConfig.getConverterType());
        methodBuilder.addCode(CodeBlock.builder()
            .beginControlFlow("if (obj.$L() != null)", getterName)
            .addStatement("$T converter = new $T()", converterType, converterType)
            .addStatement("map.put($S, converter.toMap(obj.$L()))", mapKey, getterName)
            .endControlFlow()
            .build());
    }

    private void generateCustomConverterFromMapCode(MethodSpec.Builder methodBuilder, 
                                                  ExternalMappingConfig.ExternalFieldConfig fieldConfig, 
                                                  String setterName) {
        TypeName converterType = TypeName.get(fieldConfig.getConverterType());
        methodBuilder.addCode(CodeBlock.builder()
            .beginControlFlow("if (value != null)")
            .addStatement("$T converter = new $T()", converterType, converterType)
            .addStatement("obj.$L(converter.fromMap(value))", setterName)
            .endControlFlow()
            .build());
    }

    private void generateExternalCollectionToMapCode(MethodSpec.Builder methodBuilder, 
                                                   ExternalMappingConfig.ExternalFieldConfig fieldConfig, 
                                                   String getterName, String mapKey) {
        TypeName elementType = TypeName.get(fieldConfig.getElementType());
        
        methodBuilder.addCode(CodeBlock.builder()
            .beginControlFlow("if (obj.$L() != null && !obj.$L().isEmpty())", getterName, getterName)
            .addStatement("$T<Object> list = new $T<>()", List.class, ArrayList.class)
            .beginControlFlow("for ($T item : obj.$L())", elementType, getterName)
            .build());
        
        if (fieldConfig.isExternalCollection()) {
            String externalMapperName = getSimpleTypeName(fieldConfig.getElementType()) + "FastMapper_";
            methodBuilder.addCode(CodeBlock.builder()
                .beginControlFlow("if (item != null)")
                .addStatement("list.add($L.toMap(item))", externalMapperName)
                .nextControlFlow("else")
                .addStatement("list.add(null)")
                .endControlFlow()
                .build());
        } else {
            methodBuilder.addStatement("list.add(item)");
        }
        
        methodBuilder.addCode(CodeBlock.builder()
            .endControlFlow()
            .addStatement("map.put($S, list)", mapKey)
            .endControlFlow()
            .build());
    }

    private void generateExternalCollectionFromMapCode(MethodSpec.Builder methodBuilder, 
                                                     ExternalMappingConfig.ExternalFieldConfig fieldConfig, 
                                                     String setterName) {
        TypeName elementType = TypeName.get(fieldConfig.getElementType());
        
        methodBuilder.addCode(CodeBlock.builder()
            .beginControlFlow("if (value instanceof $T)", List.class)
            .addStatement("$T<?> list = ($T<?>) value", List.class, List.class)
            .build());
        
        generateCollectionCreationByType(methodBuilder, fieldConfig, elementType);
        
        methodBuilder.addCode(CodeBlock.builder()
            .beginControlFlow("for (Object item : list)")
            .build());
        
        if (fieldConfig.isExternalCollection()) {
            generateExternalCollectionItemFromMapCode(methodBuilder, fieldConfig, elementType);
        } else {
            methodBuilder.addCode(CodeBlock.builder()
                .beginControlFlow("if (item != null)")
                .addStatement("result.add(($T) item)", elementType)
                .nextControlFlow("else")
                .addStatement("result.add(null)")
                .endControlFlow()
                .build());
        }
        
        methodBuilder.endControlFlow();
        
        if (fieldConfig.getCollectionType() == com.mapconverter.processor.FieldInfo.CollectionType.ARRAY) {
            methodBuilder.addStatement("obj.$L(result.toArray(new $T[0]))", setterName, elementType);
        } else {
            methodBuilder.addStatement("obj.$L(result)", setterName);
        }
        
        methodBuilder.endControlFlow();
    }

    private void generateCollectionCreationByType(MethodSpec.Builder methodBuilder, 
                                                ExternalMappingConfig.ExternalFieldConfig fieldConfig, 
                                                TypeName elementType) {
        switch (fieldConfig.getCollectionType()) {
            case LIST:
                methodBuilder.addStatement("$T<$T> result = new $T<>()", List.class, elementType, ArrayList.class);
                break;
            case SET:
                methodBuilder.addStatement("$T<$T> result = new $T<>()", Set.class, elementType, HashSet.class);
                break;
            case ARRAY:
                methodBuilder.addStatement("$T<$T> result = new $T<>()", List.class, elementType, ArrayList.class);
                break;
        }
    }

    private void generateExternalCollectionItemFromMapCode(MethodSpec.Builder methodBuilder, 
                                                         ExternalMappingConfig.ExternalFieldConfig fieldConfig, 
                                                         TypeName elementType) {
        String externalMapperName = getSimpleTypeName(fieldConfig.getElementType()) + "FastMapper_";
        methodBuilder.addCode(CodeBlock.builder()
            .beginControlFlow("if (item instanceof $T)", Map.class)
            .addStatement("result.add($L.fromMap(($T<String, Object>) item))", externalMapperName, Map.class)
            .nextControlFlow("else if (item != null)")
            .addStatement("result.add(($T) item)", elementType)
            .nextControlFlow("else")
            .addStatement("result.add(null)")
            .endControlFlow()
            .build());
    }

    private void generateExternalNestedObjectToMapCode(MethodSpec.Builder methodBuilder, 
                                                     ExternalMappingConfig.ExternalFieldConfig fieldConfig, 
                                                     String getterName, String mapKey) {
        String externalMapperName = getSimpleTypeName(fieldConfig.getFieldType()) + "FastMapper_";
        
        methodBuilder.addCode(CodeBlock.builder()
            .beginControlFlow("if (obj.$L() != null)", getterName)
            .addStatement("map.put($S, $L.toMap(obj.$L()))", mapKey, externalMapperName, getterName)
            .endControlFlow()
            .build());
    }

    private void generateExternalNestedObjectFromMapCode(MethodSpec.Builder methodBuilder, 
                                                       ExternalMappingConfig.ExternalFieldConfig fieldConfig, 
                                                       String setterName) {
        String externalMapperName = getSimpleTypeName(fieldConfig.getFieldType()) + "FastMapper_";
        
        methodBuilder.addCode(CodeBlock.builder()
            .beginControlFlow("if (value instanceof $T)", Map.class)
            .addStatement("obj.$L($L.fromMap(($T<String, Object>) value))", setterName, externalMapperName, Map.class)
            .endControlFlow()
            .build());
    }

    private void addExternalMapKeyConstants(TypeSpec.Builder mapperBuilder, 
                                          List<ExternalMappingConfig.ExternalFieldConfig> fieldConfigs) {
        for (ExternalMappingConfig.ExternalFieldConfig fieldConfig : fieldConfigs) {
            if (fieldConfig.isIgnored()) {
                continue;
            }
            
            String constantName = generateKeyConstantName(fieldConfig.getTargetFieldName());
            String mapKey = fieldConfig.getMapKey();
            
            mapperBuilder.addField(
                com.palantir.javapoet.FieldSpec.builder(String.class, constantName, 
                    javax.lang.model.element.Modifier.PRIVATE, 
                    javax.lang.model.element.Modifier.STATIC, 
                    javax.lang.model.element.Modifier.FINAL)
                    .initializer("$S", mapKey)
                    .build()
            );
        }
    }

    private TypeName createMapType() {
        return ParameterizedTypeName.get(
            ClassName.get(Map.class),
            ClassName.get(String.class),
            ClassName.get(Object.class)
        );
    }
}