package com.fastmapconverter.generator;

import com.fastmapconverter.processor.FieldInfo;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Generates mapper classes using JavaPoet.
 */
public class MapperCodeGenerator {
    
    private final Filer filer;
    private final Elements elementUtils;
    private final Types typeUtils;
    
    public MapperCodeGenerator(Filer filer, Elements elementUtils, Types typeUtils) {
        this.filer = filer;
        this.elementUtils = elementUtils;
        this.typeUtils = typeUtils;
    }
    
    public void generateMapper(TypeElement originalClass, String mapperClassName, List<FieldInfo> fields) throws IOException {
        String packageName = elementUtils.getPackageOf(originalClass).getQualifiedName().toString();
        ClassName originalClassName = ClassName.get(originalClass);
        ClassName mapperClass = ClassName.get(packageName, mapperClassName);
        
        TypeSpec.Builder mapperBuilder = TypeSpec.classBuilder(mapperClassName)
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addJavadoc("Generated mapper for {@link $T}\n", originalClassName)
            .addJavadoc("Provides bidirectional conversion between $T and Map&lt;String, Object&gt;\n", originalClassName);
        
        // Add toMap method
        MethodSpec toMapMethod = generateToMapMethod(originalClassName, fields);
        mapperBuilder.addMethod(toMapMethod);
        
        // Add fromMap method
        MethodSpec fromMapMethod = generateFromMapMethod(originalClassName, fields);
        mapperBuilder.addMethod(fromMapMethod);
        
        TypeSpec mapperType = mapperBuilder.build();
        
        JavaFile javaFile = JavaFile.builder(packageName, mapperType)
            .addFileComment("Generated by Fast Map Converter")
            .build();
        
        javaFile.writeTo(filer);
    }
    
    private MethodSpec generateToMapMethod(ClassName originalClass, List<FieldInfo> fields) {
        TypeName mapType = ParameterizedTypeName.get(
            ClassName.get(Map.class),
            ClassName.get(String.class),
            ClassName.get(Object.class)
        );
        
        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("toMap")
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .returns(mapType)
            .addParameter(originalClass, "obj")
            .addJavadoc("Converts a $T instance to a Map&lt;String, Object&gt;\n", originalClass)
            .addJavadoc("@param obj the object to convert\n")
            .addJavadoc("@return the resulting map\n");
        
        // Null check
        methodBuilder.addStatement("if (obj == null) return null");
        
        // Create map
        methodBuilder.addStatement("$T map = new $T<>()", mapType, HashMap.class);
        
        // Add fields to map
        for (FieldInfo field : fields) {
            if (field.isIgnored()) {
                continue;
            }
            
            String getterName = generateGetterName(field.getFieldName(), field.getFieldType());
            CodeBlock.Builder codeBlock = CodeBlock.builder();
            
            if (isPrimitive(field.getFieldType())) {
                codeBlock.addStatement("map.put($S, obj.$L())", field.getMapKey(), getterName);
            } else {
                codeBlock.beginControlFlow("if (obj.$L() != null)", getterName)
                    .addStatement("map.put($S, obj.$L())", field.getMapKey(), getterName)
                    .endControlFlow();
            }
            
            methodBuilder.addCode(codeBlock.build());
        }
        
        methodBuilder.addStatement("return map");
        
        return methodBuilder.build();
    }
    
    private MethodSpec generateFromMapMethod(ClassName originalClass, List<FieldInfo> fields) {
        TypeName mapType = ParameterizedTypeName.get(
            ClassName.get(Map.class),
            ClassName.get(String.class),
            ClassName.get(Object.class)
        );
        
        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("fromMap")
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .returns(originalClass)
            .addParameter(mapType, "map")
            .addJavadoc("Creates a $T instance from a Map&lt;String, Object&gt;\n", originalClass)
            .addJavadoc("@param map the map to convert\n")
            .addJavadoc("@return the resulting object\n");
        
        // Null check
        methodBuilder.addStatement("if (map == null) return null");
        
        // Create new instance
        methodBuilder.addStatement("$T obj = new $T()", originalClass, originalClass);
        
        // Set fields from map
        for (FieldInfo field : fields) {
            if (field.isIgnored()) {
                continue;
            }
            
            String setterName = generateSetterName(field.getFieldName());
            TypeName fieldType = TypeName.get(field.getFieldType());
            
            CodeBlock.Builder codeBlock = CodeBlock.builder();
            
            codeBlock.beginControlFlow("if (map.containsKey($S))", field.getMapKey())
                .addStatement("Object value = map.get($S)", field.getMapKey())
                .beginControlFlow("if (value != null)")
                .addStatement("obj.$L(($T) value)", setterName, fieldType)
                .endControlFlow()
                .endControlFlow();
            
            methodBuilder.addCode(codeBlock.build());
        }
        
        methodBuilder.addStatement("return obj");
        
        return methodBuilder.build();
    }
    
    private String generateGetterName(String fieldName, TypeMirror fieldType) {
        String prefix = isBoolean(fieldType) ? "is" : "get";
        return prefix + capitalize(fieldName);
    }
    
    private String generateSetterName(String fieldName) {
        return "set" + capitalize(fieldName);
    }
    
    private String capitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }
    
    private boolean isPrimitive(TypeMirror type) {
        return type.getKind().isPrimitive();
    }
    
    private boolean isBoolean(TypeMirror type) {
        return type.getKind() == TypeKind.BOOLEAN || 
               typeUtils.isSameType(type, elementUtils.getTypeElement("java.lang.Boolean").asType());
    }
}